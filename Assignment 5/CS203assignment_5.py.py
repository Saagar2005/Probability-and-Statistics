# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qiAY0WoSHrJPxOrQp-slnsWSXjv_maMe
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import beta
import ipywidgets as widgets
from IPython.display import display

# Define the observed data
data = np.array([1, 1, 1, 0, 0, 0, 1, 1, 1, 0])

# Define the prior parameters for each case
priors = [
    (2, 5),  # Beta(2,5)
    (5, 2),  # Beta(5,2)
    (1, 1),  # Beta(1,1)
    (2, 2)   # Beta(2,2)
]

# Define the grid for x values (bias of the coin)
x = np.linspace(0, 1, 1000)

# Plot posterior and prior distributions, and calculate MLE and MAP estimates for each case
plt.figure(figsize=(12, 8))
for i, prior_params in enumerate(priors, start=1):
    # Calculate posterior distribution parameters
    alpha_post = prior_params[0] + np.sum(data)
    beta_post = prior_params[1] + len(data) - np.sum(data)
    posterior = beta(alpha_post, beta_post)

    # Plot prior distribution
    plt.subplot(2, 2, i)
    prior = beta(prior_params[0], prior_params[1])
    plt.plot(x, prior.pdf(x), label='Prior', color='blue', linewidth=2)

    # Plot posterior distribution
    plt.plot(x, posterior.pdf(x), label='Posterior', color='orange', linewidth=2)

    # Plot MLE and MAP estimates
    plt.axvline(np.sum(data) / len(data), color='r', linestyle='--', label='MLE', linewidth=1.5)
    plt.axvline((alpha_post - 1) / (alpha_post + beta_post - 2), color='g', linestyle='-.', label='MAP', linewidth=1.5)

    plt.title(f'Case {i}: Beta({prior_params[0]},{prior_params[1]}) Prior', fontsize=14)
    plt.xlabel('Bias of the Coin', fontsize=12)
    plt.ylabel('Probability Density', fontsize=12)
    plt.legend(fontsize=10)

plt.tight_layout()
plt.show()

# Create sliders for prior parameters a and b
a_slider = widgets.FloatSlider(value=2, min=0.1, max=10, step=0.1, description='a:', continuous_update=False)
b_slider = widgets.FloatSlider(value=5, min=0.1, max=10, step=0.1, description='b:', continuous_update=False)

# Create input boxes for a and b
a_box = widgets.FloatText(value=2, description='a:')
b_box = widgets.FloatText(value=5, description='b:')

# Function to update the plot based on slider values
def update_plot(a, b):
    plt.figure(figsize=(10, 6))

    # Calculate posterior distribution parameters
    alpha_post = a + np.sum(data)
    beta_post = b + len(data) - np.sum(data)
    posterior = beta(alpha_post, beta_post)

    # Plot prior distribution
    prior = beta(a, b)
    plt.plot(x, prior.pdf(x), label=f'Prior (a={a}, b={b})', color='blue', linewidth=2, alpha=0.6)

    # Plot posterior distribution
    plt.plot(x, posterior.pdf(x), label='Posterior', color='orange', linewidth=2)

    # Plot MLE and MAP estimates
    plt.axvline(np.sum(data) / len(data), color='r', linestyle='--', label='MLE', linewidth=1.5)
    plt.axvline((alpha_post - 1) / (alpha_post + beta_post - 2), color='g', linestyle='-.', label='MAP', linewidth=1.5)

    plt.title('Bayesian Inference of Coin Bias', fontsize=16)
    plt.xlabel('Bias of the Coin', fontsize=14)
    plt.ylabel('Probability Density', fontsize=14)
    plt.legend(fontsize=12)
    plt.ylim(0, max(posterior.pdf(x)) * 1.2)
    plt.grid(True, linestyle='--', alpha=0.5)

    plt.show()

# Link sliders and input boxes
widgets.jslink((a_slider, 'value'), (a_box, 'value'))
widgets.jslink((b_slider, 'value'), (b_box, 'value'))

# Display sliders and input boxes
display(a_box)
display(b_box)

# Create interactive plot
widgets.interactive(update_plot, a=a_slider, b=b_slider)

